# Functions In-Depth

## Anatomy of a Function

How exactly does our code execute?

```js
var add = // function name
  function (
    a,
    b // parameters
  ) { // Declaration/Definition
    // function body
    return a + b; // function body
  }; // function body

add(3, 4, 5); // invocation / call-time (3, 4, 5) are the arguments
```

A function definition does not invoke the function, the invocation happens after the function has been called, usually by functionName(arguments).

Parameters of a function hold no value, their value is determined by the arguments passed at call-time.

## Function Scavenger Exercise

```js
var nameImprover = function(name, adj){
  return 'Col ' + name + ' Mc' + adj + ' pants';
};

$('body').hide();

myArr.forEach(function(val){ console.log(val);});

$('button').on('click', function(){
  console.log('Don\'t press any buttons!');
});

/***
 * Find: Definitions, Fn Names, Invocations, Arguments, Parameters, 
 * Fn Bodies, Return values, Side Effects
```

**Note:** Return values are anything that's explicitly returned, in this case an ES5 at least, it's explicitly returned with a return statement & then side effects are things that are happening other than returning the value that effects something outside of that function. So, `console.log` for example is a side effect because you are logging to the console that exists outside of that function or if you are changing the value of an object that's in a different scope.

## Function Scavenger Solution

- Function definitions can be spotted whenever you see the word ‘function’
- Function names come in a few flavors, in this exercise nameImprover, .hide(), .forEach(), .on(), .log(), and $ are function names
- Function bodies are whatever shows up between the {}. They do not get run until the function is invoked
Function invocations here are; return, .hide(), .forEach, console.log, .on(), $
- Function arguments and parameters. Arguments have a value, parameters are the name. Parameters; name, adj, val Arguments; ‘body’, ‘button’, ‘click’, function()…
- Function return is shown where the word ‘return’ appears. A side effect is anything that reaches beyond the {} of a function; i.e. console.log(‘I am a side effect!’). $(‘body’).hide(); is a side effect as well.

## ES6 Arrow Functions

```js
var nameImprover = (name, adj) => {
  return `Col ${name} Mc ${adj} pants`;
};

$('body').hide();

myArr.forEach(val => console.log(val));

$('button').on('click', ()=>{
  console.log('Don\'t press any buttons!');
});
```

- `=>` replaces the `function` keyword
- If there is only one parameter, it does not need to be wrapped in parenthesis.
- Arrow functions do not have their own value for `this`. Arrow functions reach into their parent scope for this.
- If you are trying to return something from an arrow function, it is best to explicitly declare the return statement.
- **Side note:** Template strings (surrounded by backticks), are ES6 syntax. It allows you to reference variable names i.e. ${variable} without the need to plus signs and quote symbols all over the place.

## Projecting Exercise

Projecting is when you take a value out of one data structure and turn it into another data structure.

Filter and then map below data structure to get the names of the final suspects to send back to the “team”

```js
const videoData = [
    {
        name: 'Miss Scarlet',
        present: true,
        rooms: [
            {kitchen: false},
            {ballroom: false},
            {conservatory: false},
            {'dining room': false},
            {'billiard room': false},
            {library: false}
        ]
    },
    {
        name: 'Mrs. White',
        present: false,
        rooms: [
            {kitchen: false},
            {ballroom: false},
            {conservatory: false},
            {'dining room': false},
            {'billiard room': false},
            {library: false}
        ]
    },
    {
        name: 'Reverend Green',
        present: true,
        rooms: [
            {kitchen: false},
            {ballroom: false},
            {conservatory: false},
            {'dining room': false},
            {'billiard room': false},
            {library: false}
        ]
    },
    {
        name: 'Rusty',
        present: false,
        rooms: [
            {kitchen: false},
            {ballroom: false},
            {conservatory: false},
            {'dining room': false},
            {'billiard room': false},
            {library: false}
        ]
    },
    {
        name: 'Colonel Mustard',
        present: true,
        rooms: [
            {kitchen: false},
            {ballroom: false},
            {conservatory: false},
            {'dining room': false},
            {'billiard room': false},
            {library: false}
        ]
    },
    {
        name: 'Professor Plum',
        present: true,
        rooms: [
            {kitchen: false},
            {ballroom: false},
            {conservatory: false},
            {'dining room': false},
            {'billiard room': false},
            {library: false}
        ]
    }
];
```

## Projecting Solution

```js
// store the return value from the filter function

const suspects = _.filter(videoData, function(suspectObject) {
    return suspectObject.present;
})

const suspectsName = _.map(suspects, suspect => {
    return suspect.name;
})
```
